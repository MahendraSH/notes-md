# MODULE 2:

- Software Development Methodologies:
- The old way and the new:
- The principles of conventional software engineering,
- principles of modern software management,
- transitioning to an iterative process.
- Life cycle phases.
- Software Effort Estimation, \
- introduction,
- Where are the Estimates Done? Problems with Over- and Under-Estimates,
- the Basis for Software Estimating,
- Software Effort Estimation Techniques.

SLE: The problems with over and Under-Estimates

---

# Summery 1

Certainly! Let's delve into each topic in Module 2 in detail:

## 1. **Software Development Methodologies:**

- **Definition:** Software Development Methodologies are systematic approaches to software development that define the processes, tasks, and activities involved in building software systems. Common methodologies include Waterfall, Agile, Scrum, and DevOps.

## 2. **The Old Way and the New:**

- **Traditional vs. Agile:** Contrasting the traditional Waterfall methodology with more modern Agile approaches. The old way often involved a sequential process, while the new emphasizes flexibility, collaboration, and iterative development.

## 3. **The Principles of Conventional Software Engineering:**

- **Structured Approach:** Traditional methodologies follow a structured and linear approach where each phase must be completed before moving to the next. Emphasizes documentation, planning, and strict adherence to requirements.

## 4. **Principles of Modern Software Management:**

- **Agile Principles:** Emphasizes flexibility, collaboration, and customer feedback. Iterative development cycles and continuous delivery are key components. Responding to change is valued over strictly following a plan.

## 5. **Transitioning to an Iterative Process:**

- **Iterative Development:** Shifting from a linear development approach to an iterative one involves repeated cycles of prototyping, testing, and refinement. It allows for more flexibility and responsiveness to changing requirements.

## 6. **Life Cycle Phases:**

- **Conventional Life Cycle:** Typically involves stages like requirements gathering, design, implementation, testing, deployment, and maintenance. Each phase has specific deliverables.
- **Iterative Life Cycle:** Repeats cycles of development, testing, and feedback. Each iteration adds functionality and refines the product.

## 7. **Software Effort Estimation - Introduction:**

- **Definition:** Predicting the effort (time, resources) required for software development projects before they begin. It helps in planning and resource allocation.

## 8. **Where are the Estimates Done? Problems with Over- and Under-Estimates:**

- **Estimation Locations:** Estimates are often done at various levels, including project, task, and resource levels.
- **Problems with Over-Estimates:** Can lead to unnecessary resource allocation and increased project costs.
- **Problems with Under-Estimates:** May result in insufficient resources, missed deadlines, and compromised quality.

## 9. **The Basis for Software Estimating:**

- **Factors Considered:** Estimations are based on factors such as project complexity, team expertise, historical data, and the clarity of requirements.

## 10. **Software Effort Estimation Techniques:**

- **Expert Judgment:** Involves seeking input from experienced individuals.
- **Algorithmic Models:** Use mathematical formulas and historical data to predict effort.
- **Comparative Estimation:** Comparing the new project to previously completed projects.

## SLE: The Problems with Over and Under-Estimates:

- **Over-Estimates:** Can lead to excessive resource allocation, increased costs, and potential delays. It may result in a project being perceived as more complex than it actually is.
- **Under-Estimates:** May lead to inadequate resource allocation, missed deadlines, and compromised quality. It can strain the development team and negatively impact customer satisfaction.

Understanding these topics provides insights into different software development methodologies, the shift towards iterative processes, and the challenges associated with software effort estimation.

# Summery 2

Certainly! Let's delve deeper into each topic:

### 1. **Software Development Methodologies:**

- **Definition:** Software Development Methodologies are systematic approaches to software development that prescribe the processes, tasks, and activities involved in building software systems. Examples include Waterfall, Agile, Scrum, and DevOps.

### 2. **The Old Way and the New:**

- **Traditional vs. Agile:** The traditional Waterfall methodology follows a linear, sequential process where each phase must be completed before moving on. Agile methodologies emphasize flexibility, collaboration, and iterative development, allowing for frequent reassessment and adaptation.

### 3. **The Principles of Conventional Software Engineering:**

- **Structured Approach:** Traditional methodologies, like Waterfall, follow a structured and plan-driven approach. Key principles include rigorous documentation, a focus on detailed planning, and a strict adherence to requirements.

### 4. **Principles of Modern Software Management:**

- **Agile Principles:** Modern software management principles, as seen in Agile methodologies, prioritize individuals and interactions over processes and tools, working software over comprehensive documentation, customer collaboration over contract negotiation, and responding to change over following a plan.

### 5. **Transitioning to an Iterative Process:**

- **Iterative Development:** Moving from a traditional to an iterative process involves embracing shorter development cycles, continuous feedback, and adapting to changes. It requires a cultural shift towards collaboration and flexibility.

### 6. **Life Cycle Phases:**

- **Conventional Life Cycle:** The Waterfall model typically involves distinct phases like requirements, design, implementation, testing, deployment, and maintenance, each with its set of deliverables.
- **Iterative Life Cycle:** In an iterative model, development is cyclical, with each iteration adding new features or refining existing ones based on feedback.

### 7. **Software Effort Estimation - Introduction:**

- **Definition:** Software Effort Estimation is the process of predicting the amount of effort (time, resources) required for a software development project before it begins. It helps in planning, budgeting, and resource allocation.

### 8. **Where are the Estimates Done? Problems with Over- and Under-Estimates:**

- **Estimation Locations:** Estimates are conducted at various levels, including project-level estimates, task-level estimates, and estimates for individual resources.
- **Problems with Over-Estimates:** Can lead to unnecessary resource allocation, increased project costs, and potentially reduced competitiveness in the market.
- **Problems with Under-Estimates:** May result in insufficient resources, missed deadlines, and compromised quality, leading to client dissatisfaction and potential financial losses.

### 9. **The Basis for Software Estimating:**

- **Factors Considered:** Estimations are based on factors such as project complexity, team expertise, historical data, clarity of requirements, and potential risks.

### 10. **Software Effort Estimation Techniques:**

- **Expert Judgment:** Involves seeking input from experienced individuals within the team or domain.
- **Algorithmic Models:** Utilize mathematical formulas and historical data to predict effort based on various parameters.
- **Comparative Estimation:** Compares the new project to previously completed projects to derive estimates.

### SLE: The Problems with Over and Under-Estimates:

- **Over-Estimates:** Can result in excessive resource allocation, higher costs, and a perception that the project is more challenging than it actually is.
- **Under-Estimates:** May lead to inadequate resource allocation, missed deadlines, and compromised quality, potentially harming client relationships and the reputation of the development team or organization.

These details provide a thorough understanding of software development methodologies, the transition from traditional to iterative processes, and the complexities associated with software effort estimation.
