# MODULE 2:

- Software Development Methodologies:
- The old way and the new:
- The principles of conventional software engineering,
- principles of modern software management,
- transitioning to an iterative process.
- Life cycle phases.
- Software Effort Estimation, \
- introduction,
- Where are the Estimates Done? Problems with Over- and Under-Estimates,
- the Basis for Software Estimating,
- Software Effort Estimation Techniques.

SLE: The problems with over and Under-Estimates

---

# questions

- Old ways and new ways any 10 ( word doc )
- modern process approach for Tra to itarative process (word doc )
- Life cycle phases ( life cycle pdf )

---

# ans

# Old ways and new ways any 10 ( word doc )

THE PRINCIPLES OF CONVENTIONAL SOFTWARE ENGINEERING :

1. **Make quality** #1. Quality must be `quantified` and mechanisms put into place to motivate its achievement

2. **High-quality software is possible**. `Techniques` that have been demonstrated `to increase quality` include involving the customer, prototyping, simplifying design, conducting inspections, and hiring the best people

3. **Design without documentation is not design**. I have often heard software engineers say, `"I have finished the design. All that is left is the documentation."`

4. **Design for change** : All the architectures, components, and specification techniques you use must `contribute to change`
5. **Give products to customers early**. No matter how hard you try to learn users' needs during the requirements phase, the most effective way to determine real needs is to` give users a product and let them play with it`

6. **avoid trick** : Show the world how smart you are by `avoiding tricky code`

7. **Get it right before you make it faster**. It is far `easier to make a working program run faster` than it is to make a `fast program work.` Don't worry about optimization during initial coding

8. **do not test your own software** : Software `developers should never be the primary testers of their own software`.

9. **Inspect code**. Inspecting the detailed design and code is a `much better way to find errors than testing`

10. **People are the key to success**. `Highly skilled people` with appropriate experience, talent, and training are key.

11. **Good management is more important than good technology**. `Good management motivates people to do their best`, but there are no universal "right" styles of management

12. **Use tools, but be realistic**. Software `tools make their users more efficient`.

13. **Expect excellence**. Your employees will do much better if you have `high expectations` for them.

# modern process approach for Tra to itarative process (word doc )

    TRANSITIONING TO AN ITERATIVE PROCESS

Modern software development processes have moved away from the conventional waterfall model, in which each stage of the development process is dependent on completion of the previous stage.
The economic benefits inherent in transitioning from the conventional waterfall model to an iterative development process are significant but difficult to quantify. As one benchmark of the expected economic impact of process improvement, consider the process exponent parameters of the COCOMO II model. (Appendix B provides more detail on the COCOMO model) This exponent can range from 1.01 (virtually no diseconomy of scale) to 1.26 (significant diseconomy of scale). The parameters that govern the value of the process exponent are application precedentedness, process flexibility, architecture risk resolution, team cohesion, and software process maturity.
The following paragraphs map the process exponent parameters of CO COMO II to my top 10 principles of a modern process.

- **Application precedentedness**. Domain experience is a critical factor in understanding how to plan and execute a software development project. For unprecedented systems, one of the key goals is to confront risks and establish early precedents, even if they are incomplete or experimental. This is one of the primary reasons that the software industry has moved to an iterative life-cycle process. Early iterations in the life cycle establish precedents from which the product, the process, and the plans can be elab- orated in evolving levels of detail.

- **Process flexibility**. Development of modern software is characterized by such a broad solution space and so many interrelated concerns that there is a paramount need for continuous incorporation of changes. These changes may be inherent in the problem understanding, the solution space, or the plans. Project artifacts must be supported by efficient change management commensurate with project needs. A configurable process that allows a common framework to be adapted across a range of projects is necessary to achieve a software return on investment.

- **Architecture risk resolution**. Architecture-first development is a crucial theme underlying a successful iterative development process. A project team develops and stabilizes architecture before
  developing all the components that make up the entire suite of applications components. An architecture-first and component-based development approach forces the infrastructure, common mechanisms, and control mechanisms to be elaborated early in the life cycle and drives all component make/buy decisions into the architecture process.

- **Team cohesion**. Successful teams are cohesive, and cohesive teams are successful. Successful teams and cohesive teams share common objectives and priorities. Advances in technology (such as programming languages, UML, and visual modeling) have enabled more rigorous and understandable notations for communicating software engineering information, particularly in the requirements and design artifacts that previously were ad hoc and based completely on paper exchange. These model- based formats have also enabled the round-trip engineering support needed to establish change freedom sufficient for evolving design representations.

- **Software process maturity**. The Software Engineering Institute's Capability Maturity Model (CMM) is a well-accepted benchmark for software process assessment. One of key themes is that truly mature processes are enabled through an integrated environment that provides the appropriate level of automa- tion to instrument the process for objective quality control.

## summary

The text is about the benefits and principles of transitioning from a conventional waterfall model to an iterative development process in software engineering. The text uses the COCOMO II model to measure the economic impact of process improvement, and maps its parameters to the author's top 10 principles of a modern process. These principles are:

- Application precedentedness: using domain experience and early iterations to confront risks and establish precedents.
- Process flexibility: adapting to changes and using a configurable process framework.
- Architecture risk resolution: developing and stabilizing the architecture before the components, and using a component-based approach.
- Team cohesion: sharing common objectives and priorities, and using rigorous and understandable notations for communication and design.
- Software process maturity: using an integrated environment and automation to enable quality control.

# Life cycle phases ( life cycle pdf ) :

life cycle phases -> enginerring stage / production stage
engineering stage -> inception phase / eleboration
production stage -> construction / transition

# Problems with Over- and Under-Estimates ( page -6 sw Estimates pdf)

- Under-Estimates -> less quality and press on staff and zertoh law

- over-estimates -> more time more work expands , more people also leads to more time taken , two laws

# Software Effort Estimation Techniques. ( page - 11 sw Estimates pdf )

- algorithmic model - > effort driven and predict effort
- Expert Jugment -> exprence staff
- analogy -> comparing with simlar projects
- parkinson law -> staff effort avalable is used
- price to win -> least cost to do
- to-down -> whole estamte is divided into component estimates
- bottom -up -> etimate of compoents is added to from whole
